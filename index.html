<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Voxvision: Voxvision Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Voxvision
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">Creating and manipulating voxel octrees</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Voxvision Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Voxtrees </h2>
<h3>Defining a voxel</h3>
<p>Each voxel in the <b>voxtrees</b> library is represented by the type <code>vox_dot</code>, which is just an array of 3 single float numbers. This dot type declares a vertex of a voxel with the minimal coordinates. If you add <code>vox_voxel</code> global variable to this dot, you will get another vertex of your voxel with maximal coordinates. You can imagine a Cartesian coordinate system with origin <code>{0,0,0}</code> and axes given by equations <em>x = 0</em>, <em>y = 0</em>, <em>z = 0</em>. Having just those two dots and the fact, that voxel's faces are parallel to planes given by equations above, we can define a voxel. Because of <code>vox_voxel</code> is a global variable, all voxels in the library are of the same size. </p><div class="image">
<img src="voxel.png" alt="voxel.png"/>
<div class="caption">
A voxel in voxtrees library</div></div>
<p> <b>NB:</b> If you compile your library with <code>SSE_INTRIN</code> option, <code>vox_dot</code> will be array of 4 single float values with the last of them being unused. You can still, however, use the first three elements as usual.</p>
<p><b>NB:</b> It is not recommended to set values to objects of <code>vox_dot</code> type using indices, like <code>dot[i]</code>. Insted use <code>vox_dot_set()</code> macro.</p>
<h3>Creating a tree from an array of voxels</h3>
<p>The first thing you must know how to do before doing anything else with these libraries is creation of voxel trees. There are two ways of doing this. The first way is creating from an array of voxels. Suppose you create an array <code>array</code> which contains <code>n</code> voxels and make a new tree. Then you can do it as follows:</p>
<div class="fragment"><div class="line">vox_dot *array = malloc (n * <span class="keyword">sizeof</span>(vox_dot));</div><div class="line">fill_array (array, n); <span class="comment">// Fill it as you wish</span></div><div class="line"><span class="keyword">struct </span><a class="code" href="structvox__node.html">vox_node</a> *tree = <a class="code" href="tree_8h.html#a8ac504b02b36d8c18196aa1de2147836">vox_make_tree</a> (array, n);</div><div class="line">free (array);</div></div><!-- fragment --><p><code><a class="el" href="tree_8h.html#a8ac504b02b36d8c18196aa1de2147836" title="Turn a set of voxels into a tree. ">vox_make_tree()</a></code> creates a new voxel tree and <code>free()</code> destroys the array as it is probably of no use for you anymore. Note, that if you wish to continue to use your array, you must take into account that it is sorted in <code><a class="el" href="tree_8h.html#a8ac504b02b36d8c18196aa1de2147836" title="Turn a set of voxels into a tree. ">vox_make_tree()</a></code>, so any old indices to that array will no longer point to the same elements. There are no functions in these libraries which require the old array as an argument.</p>
<p><b>NB:</b> All elements of the array must be unique and be multiple of <code>vox_voxel</code>. If you have <code>vox_voxel</code>, say, {1,1,1}, then array element of value {0.5, 0.7, 1.1} is invalid. Only whole numbers are valid here. This is probably due to the library's misdesign, that it's strongly recommended to use values for <code>vox_voxel</code> which fit good in single float precision. The default for <code>vox_voxel</code> is {1,1,1}.</p>
<p><b>NB:</b> If you compile your library with <code>SSE_INTRIN</code> option, arrays of <code>vox_dot</code>s must be 16-byte aligned. You can use <code>aligned_alloc()</code> function from standard C library for this.</p>
<h3>Manipulating and destroying the tree</h3>
<p>You can get a number of voxels in the tree by calling <code><a class="el" href="tree_8h.html#ae62ccb04887ee5dc9e4dc1df370bf8fb" title="Return number of voxels in the tree. ">vox_voxels_in_tree()</a></code> or get a bounding box for the tree with <code><a class="el" href="tree_8h.html#a561dbfaef27e5d2b21e8ca0c75664963" title="Get the bounding box for voxels in the tree. ">vox_bounding_box()</a></code>. See API documentation for details.</p>
<p>You can also insert and delete voxels in the existing tree. This is slower than creating tree from an array. Not to be specific, I just say, that <code><a class="el" href="tree_8h.html#a8ac504b02b36d8c18196aa1de2147836" title="Turn a set of voxels into a tree. ">vox_make_tree()</a></code> can create trees of tens of millions voxels in one or two seconds, while inserting in a live tree can give you rate just one million voxels per second on the same machine. Let's see some code examples to learn how to do this:</p>
<div class="fragment"><div class="line">vox_dot dot; </div><div class="line"><span class="keywordtype">int</span> res;</div><div class="line"><span class="keyword">struct </span><a class="code" href="structvox__node.html">vox_node</a> *tree = NULL; <span class="comment">// NULL is always understood as an empty tree</span></div><div class="line">vox_dot_set (dot, 1, 2, 3); <span class="comment">// Like dot[0] = 1; dot[1] = 2; dot[2] = 3;</span></div><div class="line">res = <a class="code" href="tree_8h.html#af79a04cd87e83c267f60f74f5f457f7d">vox_insert_voxel</a> (&amp;tree, dot);</div><div class="line"><span class="comment">// Now res is 1 (success), and tree points to a newly created tree</span></div><div class="line">res = <a class="code" href="tree_8h.html#af79a04cd87e83c267f60f74f5f457f7d">vox_insert_voxel</a> (&amp;tree, dot);</div><div class="line"><span class="comment">// It&#39;s OK to try to insert the same voxel, res is now 0 (not successful)</span></div><div class="line">res = <a class="code" href="tree_8h.html#a8d9487756c490fa452920f6d13415729">vox_delete_voxel</a> (&amp;tree, dot);</div><div class="line"><span class="comment">// res is 1 (success), voxel is deleted and the tree has no voxels</span></div><div class="line"></div><div class="line"><span class="comment">// Assume now vox_voxel is {1,1,1} (default)</span></div><div class="line">vox_dot_set (dot, 0.2, 0.3, 1.5);</div><div class="line"><a class="code" href="tree_8h.html#af79a04cd87e83c267f60f74f5f457f7d">vox_insert_voxel</a> (&amp;tree, dot);</div><div class="line"><span class="comment">// This is OK, voxel with value {0,0,1} will be inserted.</span></div><div class="line"><span class="comment">// vox_insert_voxel() inserts vox_voxel-aligned voxel.</span></div></div><!-- fragment --><p>I do not recommend to use these functions when you create a tree from scratch, use <code><a class="el" href="tree_8h.html#a8ac504b02b36d8c18196aa1de2147836" title="Turn a set of voxels into a tree. ">vox_make_tree()</a></code> instead. Many calls to <code><a class="el" href="tree_8h.html#af79a04cd87e83c267f60f74f5f457f7d" title="Insert a voxel in the tree on the fly. ">vox_insert_voxel()</a></code> or <code><a class="el" href="tree_8h.html#a8d9487756c490fa452920f6d13415729" title="Delete a voxel from the tree on the fly. ">vox_delete_voxel()</a></code> can make your tree unbalanced. You can rebuild a tree completely with <code><a class="el" href="tree_8h.html#a67b66bb7b1741b5c3687ad432a85bea1" title="Rebuild a tree. ">vox_rebuild_tree()</a></code> function.</p>
<p>There are 2 common patterns which insertion/deletion functions recognize.</p>
<ul>
<li>Inserting voxels one-by-one so there is no gap between them. This pattern is common in loops with counters like the one below. <div class="fragment"><div class="line"><span class="keywordflow">for</span> (k=0; k&lt;K; k++)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (l=0; l&lt;L; l++)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span> (m=0; m&lt;M; m++)</div><div class="line">        {</div><div class="line">            vox_dot_set (dot,</div><div class="line">                         <a class="code" href="params_8h.html#a711c3edcd4361559a8906262616ec2e3">vox_voxel</a>[0]*k,</div><div class="line">                         <a class="code" href="params_8h.html#a711c3edcd4361559a8906262616ec2e3">vox_voxel</a>[1]*l,</div><div class="line">                         <a class="code" href="params_8h.html#a711c3edcd4361559a8906262616ec2e3">vox_voxel</a>[2]*m);</div><div class="line">            <a class="code" href="tree_8h.html#af79a04cd87e83c267f60f74f5f457f7d">vox_insert_voxel</a> (&amp;tree, dot);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> This will work very fast and will be very efficient in the sense of memory consumption, because of use of so-called "dense nodes" within the library. On the other hand, deletion from these dense nodes is very inefficient (about 3 times slower than deletion from ordinary nodes). Also please note, that if all you deserve is a tree consisting of just one big box, you can just use <code><a class="el" href="tree_8h.html#ac275f17adfc58a39e2fb0ffa2823a89e" title="Create a cuboid tree. ">vox_make_dense_leaf()</a></code> function instead of inserting voxels one-by-one in a loop.</li>
<li>Insertion/deletion of the furthermost random voxels. When inserting/deleting random voxels, try to do it with furthermost voxles first. When inserting it will help to calculate internal data of voxel nodes properly, so voxels are distributed more evenly in the tree. When deleting it will also keep the tree balanced.</li>
</ul>
<p>When the tree is no longer needed it must be destroyed with <code><a class="el" href="tree_8h.html#ac50cbac22d22e2dde862abd1bf35aaec" title="Free resources used by a tree. ">vox_destroy_tree()</a></code> function. Trees with no voxels in them need not to be destroyed (remember, they are just <code>NULL</code>).</p>
<h3>Searching</h3>
<p>This is the reason why <b>voxtrees</b> library exists. It can perform various types of search much faster than if we would try to do it with naïve <code>O(n)</code> search.</p>
<p>You can check if a ball intersects any voxel in the tree with <code><a class="el" href="search_8h.html#a6183f3286a62c6ea3a75b671ccd39736" title="Find out if a ball collides with voxels in a tree. ">vox_tree_ball_collidep()</a></code>: </p><div class="fragment"><div class="line">vox_dot center = {0,0,0};</div><div class="line"><span class="keywordtype">float</span> radius = 10;</div><div class="line"><span class="keywordtype">int</span> interp = <a class="code" href="search_8h.html#a6183f3286a62c6ea3a75b671ccd39736">vox_tree_ball_collidep</a> (tree, center, radius);</div><div class="line"><span class="keywordflow">if</span> (interp) printf (<span class="stringliteral">&quot;There is/are voxel(s) close enough to {0,0,0}\n&quot;</span>);</div></div><!-- fragment --><p>You can find where a ray hits the first voxel on its path through the tree. There is a function <code><a class="el" href="search_8h.html#aaf72ddf549c534e5ee1a5162ed40f96d" title="Find intersection of a tree and a ray. ">vox_ray_tree_intersection()</a></code> for that. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structvox__node.html">vox_node</a> *leaf;</div><div class="line">vox_dot origin = {0,0,0};</div><div class="line">vox_dot direction = {1,1,1}; <span class="comment">// May be a vector of any length</span></div><div class="line">vox_dot intersection;</div><div class="line">leaf = <a class="code" href="search_8h.html#aaf72ddf549c534e5ee1a5162ed40f96d">vox_ray_tree_intersection</a> (tree, origin, direction, intersection);</div><div class="line"><span class="keywordflow">if</span> (leaf != NULL) printf (<span class="stringliteral">&quot;There is intersection at &lt;%f, %f, %f&gt;\n&quot;</span>,</div><div class="line">                          intersection[0], intersection[1], intersection[2]);</div></div><!-- fragment --><p> In the latter example the leaf node is returned where intersection is found or <code>NULL</code> if there is no intersection. Note, that empty nodes (with no voxels in them) are also <code>NULL</code>, but there are no intersections with them in any case.</p>
<h2>Voxrnd </h2>
<h3>Rendering</h3>
<p><b>voxrnd</b> is a rendering library which works in conjunction with <b>voxtrees</b> library. The rendering is performed via a context object, <code>struct <a class="el" href="structvox__rnd__ctx.html" title="A renderer context. ">vox_rnd_ctx</a></code>. You can choose one of two backends: a window managed by context or a previously created SDL surface. A context which renders directly to window is created by <code><a class="el" href="renderer_8h.html#aaf81b81464cedd74adb3ef36a45bb977" title="Create a window and attach context to it. ">vox_make_context_and_window()</a></code> and the one which renders to SDL surface is created by <code><a class="el" href="renderer_8h.html#a9fd08193262065eb1e8decc9a03504bb" title="Make a renderer context from SDL surface. ">vox_make_context_from_surface()</a></code>. Then you can render a tree by calling <code><a class="el" href="renderer_8h.html#ade0726b6cf99eab1508e6e7e6bc72480" title="Render a scene on SDL surface. ">vox_render()</a></code> supplying the context as argument. Also you need to attach your scene (currently it's just a tree) and a camera to your context. This can be done by calling <code><a class="el" href="renderer_8h.html#a70b28356c826fe55a989c88130365aba" title="Scene setter for renderer context. ">vox_context_set_scene()</a></code> and <code><a class="el" href="renderer_8h.html#a67d94618f634ad5c180883893c70dcea" title="Camera setter for renderer context. ">vox_context_set_camera()</a></code>. After you call <code><a class="el" href="renderer_8h.html#ade0726b6cf99eab1508e6e7e6bc72480" title="Render a scene on SDL surface. ">vox_render()</a></code>, you must call <code><a class="el" href="renderer_8h.html#a91509c84451323b39ba51d6e334115ac" title="Redraw a window associated with this context. ">vox_redraw()</a></code> to copy rendered image from the context's internals to the screen or surface. The reason for why <code><a class="el" href="renderer_8h.html#ade0726b6cf99eab1508e6e7e6bc72480" title="Render a scene on SDL surface. ">vox_render()</a></code> and <code><a class="el" href="renderer_8h.html#a91509c84451323b39ba51d6e334115ac" title="Redraw a window associated with this context. ">vox_redraw()</a></code> are separated is because <code><a class="el" href="renderer_8h.html#ade0726b6cf99eab1508e6e7e6bc72480" title="Render a scene on SDL surface. ">vox_render()</a></code> can be called from any thread and <code><a class="el" href="renderer_8h.html#a91509c84451323b39ba51d6e334115ac" title="Redraw a window associated with this context. ">vox_redraw()</a></code> only from the main one (that one which called <code>SDL_Init()</code>).</p>
<p>You can create the camera using constructor from a structure called camera interface. <b>voxrnd</b> currently provides 2 camera classes, and therefore 2 implementations of camera interface. You can get an implementation of camera interface by calling camera methods getter, <code><a class="el" href="camera_8h.html#a199454676668e236a54b155e1a38244e" title="Get camera methods. ">vox_camera_methods()</a></code>. It accepts a camera name as its only argument. Possible camera names are: <code>"simple-camera"</code> and <code>"doom-camera"</code>. The first camera, despite the name, is fully functional camera with six degrees of freedom, and the second is an old-fashioned but fast doom-like camera with five degrees of freedom.</p>
<p>To create a simple camera you must write something like this: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structvox__camera.html">vox_camera</a>* camera = <a class="code" href="camera_8h.html#a199454676668e236a54b155e1a38244e">vox_camera_methods</a> (<span class="stringliteral">&quot;simple-camera&quot;</span>)-&gt;<a class="code" href="structvox__camera__interface.html#aceb9838fe97778a38bc7d83352cee3e6">construct_camera</a> (NULL);</div></div><!-- fragment --><p> <code>construct_camera()</code> here is a constructor. It's argument is another camera instance or <code>NULL</code>. If it is not <code>NULL</code>, a newly created camera will inherit all internal fields (as rotation angles, position, etc.) from supplied camera. The supplied camera must be of the same class as the newly created or from a related class with the same data layout. Behaviour is undefined if this condition does not hold. You can also set the camera's field of view and position (otherwise they will remain at their default values, depending on camera's implementation): </p><div class="fragment"><div class="line">camera-&gt;<a class="code" href="structvox__camera.html#a8b182ba67759a14b47e55627ca9004b7">iface</a>-&gt;set_fov (camera, 1.2);</div><div class="line">vox_dot position = {-10, 10, 100};</div><div class="line">camera-&gt;<a class="code" href="structvox__camera.html#a8b182ba67759a14b47e55627ca9004b7">iface</a>-&gt;set_position (camera, position); <span class="comment">// Here argument is copied.</span></div></div><!-- fragment --><p><b>NB:</b> Starting with version 0.32 you must use different construction for setting FOV and position: </p><div class="fragment"><div class="line">camera-&gt;<a class="code" href="structvox__camera.html#a8b182ba67759a14b47e55627ca9004b7">iface</a>-&gt;set_property_number (camera, <span class="stringliteral">&quot;fov&quot;</span>, 1.2);</div><div class="line">vox_dot position = {-10, 10, 100};</div><div class="line">camera-&gt;<a class="code" href="structvox__camera.html#a8b182ba67759a14b47e55627ca9004b7">iface</a>-&gt;set_property_dot (camera, <span class="stringliteral">&quot;position&quot;</span>, position);</div></div><!-- fragment --><p> This change was made to reduce overall interface size and, what's more important, to allow user to pass different specific parameters to objects in a uniform way.</p>
<p>Putting it all together you will get something like this:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structvox__node.html">vox_node</a> *tree = <a class="code" href="tree_8h.html#a8ac504b02b36d8c18196aa1de2147836">vox_make_tree</a> (voxels, n);</div><div class="line">vox_dot origin = {0,0,0}; <span class="comment">// Camera&#39;s origin</span></div><div class="line"><span class="keywordtype">float</span> fov = 1.2; <span class="comment">// Camera&#39;s field of view</span></div><div class="line"><span class="comment">// Make a default camera</span></div><div class="line"><span class="keyword">struct </span><a class="code" href="structvox__camera.html">vox_camera</a> *camera = <a class="code" href="camera_8h.html#a199454676668e236a54b155e1a38244e">vox_camera_methods</a> (<span class="stringliteral">&quot;simple-camera&quot;</span>)-&gt;<a class="code" href="structvox__camera__interface.html#aceb9838fe97778a38bc7d83352cee3e6">construct_camera</a> (NULL);</div><div class="line">camera-&gt;<a class="code" href="structvox__camera.html#a8b182ba67759a14b47e55627ca9004b7">iface</a>-&gt;set_property_dot (camera, <span class="stringliteral">&quot;position&quot;</span>, origin);</div><div class="line">camera-&gt;<a class="code" href="structvox__camera.html#a8b182ba67759a14b47e55627ca9004b7">iface</a>-&gt;set_property_number (camera, <span class="stringliteral">&quot;fov&quot;</span>, fov);</div><div class="line"><span class="keyword">struct </span><a class="code" href="structvox__rnd__ctx.html">vox_rnd_ctx</a> *ctx =</div><div class="line">     <a class="code" href="renderer_8h.html#a9fd08193262065eb1e8decc9a03504bb">vox_make_context_from_surface</a> (<a class="code" href="structvox__rnd__ctx.html#a50030928dd30ff6222f064eef028837b">surface</a>);</div><div class="line"><a class="code" href="renderer_8h.html#a70b28356c826fe55a989c88130365aba">vox_context_set_scene</a> (ctx, tree);</div><div class="line"><a class="code" href="renderer_8h.html#a67d94618f634ad5c180883893c70dcea">vox_context_set_camera</a> (ctx, camera);</div><div class="line"><a class="code" href="renderer_8h.html#ade0726b6cf99eab1508e6e7e6bc72480">vox_render</a> (ctx);</div><div class="line"><a class="code" href="renderer_8h.html#a91509c84451323b39ba51d6e334115ac">vox_redraw</a> (ctx);</div><div class="line">SDL_SaveBMP (<a class="code" href="structvox__rnd__ctx.html#a50030928dd30ff6222f064eef028837b">surface</a>, <span class="stringliteral">&quot;rendering.bmp&quot;</span>);</div><div class="line">camera-&gt;<a class="code" href="structvox__camera.html#a8b182ba67759a14b47e55627ca9004b7">iface</a>-&gt;<a class="code" href="structvox__camera__interface.html#aadef8e7896e388e1827b992bae420cb7">destroy_camera</a> (camera); <span class="comment">// Destroy the camera</span></div><div class="line"><a class="code" href="tree_8h.html#ac50cbac22d22e2dde862abd1bf35aaec">vox_destroy_tree</a> (tree); <span class="comment">// Destroy the tree</span></div><div class="line"><a class="code" href="renderer_8h.html#a841eebeafb562b82586aebc19666c01f">vox_destroy_context</a> (ctx); <span class="comment">// Destroy the context</span></div><div class="line">SDL_FreeSurface (<a class="code" href="structvox__rnd__ctx.html#a50030928dd30ff6222f064eef028837b">surface</a>);</div><div class="line"><span class="comment">// And so on</span></div></div><!-- fragment --><p> This will produce a visualisation of the tree saved in <code>rendering.bmp</code></p>
<p>Another example is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structvox__node.html">vox_node</a> *tree = <a class="code" href="tree_8h.html#a8ac504b02b36d8c18196aa1de2147836">vox_make_tree</a> (voxels, n);</div><div class="line"><span class="comment">// Make a default camera as earlier</span></div><div class="line"><span class="keyword">struct </span><a class="code" href="structvox__camera.html">vox_camera</a> *camera = <a class="code" href="camera_8h.html#a199454676668e236a54b155e1a38244e">vox_camera_methods</a> (<span class="stringliteral">&quot;simple-camera&quot;</span>)-&gt;<a class="code" href="structvox__camera__interface.html#aceb9838fe97778a38bc7d83352cee3e6">construct_camera</a> (NULL);</div><div class="line"><span class="comment">// Make 800x600 window</span></div><div class="line"><span class="keyword">struct </span><a class="code" href="structvox__rnd__ctx.html">vox_rnd_ctx</a> *ctx =</div><div class="line">     <a class="code" href="renderer_8h.html#aaf81b81464cedd74adb3ef36a45bb977">vox_make_context_and_window</a> (800, 600);</div><div class="line"><a class="code" href="renderer_8h.html#a70b28356c826fe55a989c88130365aba">vox_context_set_scene</a> (ctx, tree);</div><div class="line"><a class="code" href="renderer_8h.html#a67d94618f634ad5c180883893c70dcea">vox_context_set_camera</a> (ctx, camera);</div><div class="line"><span class="comment">// Render to internal surface</span></div><div class="line"><a class="code" href="renderer_8h.html#ade0726b6cf99eab1508e6e7e6bc72480">vox_render</a> (ctx);</div><div class="line"><span class="comment">// And put the result on the screen</span></div><div class="line"><a class="code" href="renderer_8h.html#a91509c84451323b39ba51d6e334115ac">vox_redraw</a> (ctx);</div><div class="line">camera-&gt;<a class="code" href="structvox__camera.html#a8b182ba67759a14b47e55627ca9004b7">iface</a>-&gt;<a class="code" href="structvox__camera__interface.html#aadef8e7896e388e1827b992bae420cb7">destroy_camera</a> (camera); <span class="comment">// Destroy the camera</span></div><div class="line"><a class="code" href="tree_8h.html#ac50cbac22d22e2dde862abd1bf35aaec">vox_destroy_tree</a> (tree); <span class="comment">// Destroy the tree</span></div><div class="line"><a class="code" href="renderer_8h.html#a841eebeafb562b82586aebc19666c01f">vox_destroy_context</a> (ctx); <span class="comment">// Destroy the context</span></div></div><!-- fragment --> <h3>Quality settings</h3>
<div class="image">
<img src="rnd.png" alt="rnd.png"/>
<div class="caption">
Rendering pass in voxrnd</div></div>
<p><b>voxrnd</b> performs an important optimization which allows it to work more or less quickly, but has a penalty in quality degradation, so this is a quality-speed trade-off. To controll the balance, there are three quality modes in <b>voxrnd</b>. To understand it, you need to understand how <b>voxrnd</b> works. First of all, for any context it allocates an array of blocks 4x4 pixels each. Here comes current restriction on screen resolution: its width must be an integral multiple of 16, and its height must be an integral multiple of 4. Fortunately, all mainstream resolutions, like 640x480, 800x600, 1280x1024 or 1920x1080 are OK. Then, when you call <code><a class="el" href="renderer_8h.html#ade0726b6cf99eab1508e6e7e6bc72480" title="Render a scene on SDL surface. ">vox_render()</a></code>, <b>voxrnd</b> casts a ray for each pixel on the screen (currently, exactly one ray for one pixel). The process is sequential for each pixel in a block, but is parallelized between the blocks (see picture above, where solid black squares are blocks, red squares are pixels and Z-shaped line is an order which is used to render a block). Parallelization means that you can benifit from multicore CPU. As you can see, rendering inside a block is performed in Z-order. When our rendering is ready, <code><a class="el" href="renderer_8h.html#a91509c84451323b39ba51d6e334115ac" title="Redraw a window associated with this context. ">vox_redraw()</a></code> copies array of block into an ordinary SDL surface which is rendered to the screen.</p>
<p>There is our optimization: for any next pixel <b>voxrnd</b> does not run a search in the tree starting from its root node, but it uses a leaf node obtained from the previous search. It runs from the root only if this mechanism does not find an intersection. Surely, this adds some rendering artifacts (usually, they are observed at edges of objects), but speeds up things a lot. The quality setting for this mode is called <em>fast</em>.</p>
<p>There is also the setting called <em>best</em>. In this mode, the search is started from the root for each pixel.</p>
<p>Finally, there is <em>adaptive</em> mode. In this mode, the renderer chooses from <em>fast</em> and <em>best</em> mode for each block individually. The choice depends on distance between intersections for the first and the last pixels in the block (see picture). This gives a rendering similar to one with <em>best</em> quality and rendering speed somewhat in between <em>best</em> and <em>fast</em> (it depends on the tree to be rendered).</p>
<p>All these modes are selected using <code><a class="el" href="renderer_8h.html#a2c56ead0dc18d42d0235bbd247e6620c" title="Set quality of the renderer. ">vox_context_set_quality()</a></code> function which you can call anytime between two <code><a class="el" href="renderer_8h.html#ade0726b6cf99eab1508e6e7e6bc72480" title="Render a scene on SDL surface. ">vox_render()</a></code> calls. The defalut mode is <em>adaptive</em>.</p>
<h3>Ray merging</h3>
<p>Reusing a leaf obtained from a previous step works best when you are close enough to some object, so all rays belonging to one block hit voxels belonging to one leaf in the tree. On long distances from the camera's origin there is another optimization called <em>ray merging</em> which works in conjunction with adaptive rendering mode. In this mode, when its likely that a ray belonging to every second column on the screen will travel a long way from the camera, it is simply merged with corresponding ray from every first column. Merging means that no search is performed for a merged ray and two subsequent pixels on the screen will have the same value. This is illustrated on the picture below. On this picture, for example, the second ray (from the left) is merged with the first when it's likely that it will travel a long distance (merging is shown with dash line). Note, that my renderer has no means to determine actuall distance traveled by a ray (all rays are of infinite length, so it's a ray in mathematical sence, not just a line segment), but can predict more or less precisely the distance between the camera and an intersection with the tree for rays in a block. So the decision to merge or not to merge is evaluted on per-block basis, not for every ray individually. </p><div class="image">
<img src="ray-merge.png" alt="ray-merge.png"/>
<div class="caption">
Ray merging scheme</div></div>
<p> There are two modes of ray merging: <em>fast</em> and <em>accurate</em>. <em>Fast</em> means that ray merging is performed for those blocks which have long distances between the camera origin and intersections with the tree. <em>Accurate</em> mode disables ray merging on edges of objects and some other problematic zones. Here is a demonstration (here, merged rays produce blue dots for clarity). </p><div class="image">
<img src="ray-merge-example.png" alt="ray-merge-example.png"/>
<div class="caption">
Fast ray merging (left) vs accurate ray merging (right)</div></div>
<p>You can enable ray merging with <code><a class="el" href="renderer_8h.html#a2c56ead0dc18d42d0235bbd247e6620c" title="Set quality of the renderer. ">vox_context_set_quality()</a></code> OR'ing <code>VOX_QUALITY_ADAPTIVE</code> with either <code>VOX_QUALITY_RAY_MERGE</code> or <code>VOX_QUALITY_RAY_MERGE_ACCURATE</code>.</p>
<h3>Cameras</h3>
<p>Let's talk more about cameras and their interfaces. There are few structures to work with cameras. The first is <code>struct <a class="el" href="structvox__camera.html" title="A generic camera class. ">vox_camera</a></code>. It is a generic camera class. All interface functions accept objects of this class as their first argument. Constructors also return objects of this type. There are more specified camera classes, which are implemented as shared modules (plug-ins). As mentioned before, standard modules are <code>simple-camera</code> and <code>doom-camera</code>. There is also <code>struct <a class="el" href="structvox__camera__interface.html" title="A camera user interface. ">vox_camera_interface</a></code> structure. It contains a camera interface implementation, in other words, a set of functions, visible both to the library and to the user and which any camera class must implement to define a working camera. Of course, often you may wish to implement two or more camera classes, which share their data layout (defined by the same structure), but implement camera interface differently (like FPS camera and third-person view camera). Then you can "inherit" some of the basic methods (like setting camera's position or field of view) using <code><a class="el" href="camera_8h.html#a236708c66fcdd31f5da2d34654a8fb7b" title="Use defined camera methods from another interface implementation. ">vox_use_camera_methods()</a></code> function, which takes <code>struct <a class="el" href="structvox__camera__interface.html" title="A camera user interface. ">vox_camera_interface</a></code> structure and copies all defined methods from it to a specified camera.</p>
<p>There are two types of methods in camera interface. The first is class methods, like a camera constructor. The common pattern to call them is using camera methods getter, <code><a class="el" href="camera_8h.html#a199454676668e236a54b155e1a38244e" title="Get camera methods. ">vox_camera_methods()</a></code>: </p><div class="fragment"><div class="line"><a class="code" href="camera_8h.html#a199454676668e236a54b155e1a38244e">vox_camera_methods</a> (cam_name)-&gt;class_method (args); <span class="comment">// The pattern</span></div><div class="line"><a class="code" href="camera_8h.html#a199454676668e236a54b155e1a38244e">vox_camera_methods</a> (<span class="stringliteral">&quot;doom-camera&quot;</span>)-&gt;<a class="code" href="structvox__camera__interface.html#aceb9838fe97778a38bc7d83352cee3e6">construct_camera</a> (NULL); <span class="comment">// An example</span></div></div><!-- fragment --><p> The second is instance methods. The pattern for them is: </p><div class="fragment"><div class="line"><a class="code" href="structvox__camera.html">vox_camera</a> *<a class="code" href="structvox__rnd__ctx.html#a84a9fd7bdce001b6b46b32f639564de9">camera</a>;</div><div class="line"><span class="comment">// Initialization skipped</span></div><div class="line">camera-&gt;<a class="code" href="structvox__camera.html#a8b182ba67759a14b47e55627ca9004b7">iface</a>-&gt;instance_method (camera, args); <span class="comment">// The pattern</span></div><div class="line">camera-&gt;<a class="code" href="structvox__camera.html#a8b182ba67759a14b47e55627ca9004b7">iface</a>-&gt;<a class="code" href="structvox__camera__interface.html#aadef8e7896e388e1827b992bae420cb7">destroy_camera</a> (camera); <span class="comment">// An example</span></div></div><!-- fragment --><p>As you can see, each camera object contains a copy of <code>struct <a class="el" href="structvox__camera__interface.html" title="A camera user interface. ">vox_camera_interface</a></code> structure where an implementation of camera interface is stored. To call an instance method you must always use <code>camera-&gt;iface</code> to refer to the camera's methods. To call a class method you can use both <code>camera-&gt;iface</code> (if you already have an instance of that class) or camera methods getter.</p>
<p>The goal which is achieved by keeping camera interface and camera implementation apart is to make it possible for user to define his/her own camera classes. You can see how this can be done by seeing source code for 2 camera classes which are available in <b>voxrnd</b> library. I'll try to make a guide for that later. You can get more info on camera interface in <code>struct <a class="el" href="structvox__camera__interface.html" title="A camera user interface. ">vox_camera_interface</a></code> documentation.</p>
<div class="image">
<img src="camcoord.png" alt="camcoord.png"/>
<div class="caption">
A coordinate system of a camera</div></div>
<p>On the picture above you can see the camera's coordinate system. It is projected on the screen exactly as on the picture (i.e. the camera's X maps exactly to the screen's right, etc). The Y direction is always "forwards" for you. As for rotation around the axes, the positive direction is clockwise. Be careful with coordinate systems, as some of the camera's methods require coordinates in its own coordinate system (these are usually "incremental" methods as <code>camera-&gt;iface-&gt;move_camera()</code>) and some require coordinates in the world's coordinate system (these usually do some "absolute" or "non incremental" stuff, an example: <code>camera-&gt;iface-&gt;set_position()</code>).</p>
<h3>Collision detection</h3>
<p>Unfortunately, currently you cannot move the whole tree to any direction, so there is no tree-to-tree collision detection. But there is collision detection mechanism for a camera. This mechanism can be created by calling <code><a class="el" href="cd_8h.html#a9a5c42383ece1e3542105c3b29dd6ded" title="Create collision detector. ">vox_make_cd()</a></code> which returns an object of type <code>struct <a class="el" href="structvox__cd.html" title="Opaque structure for collision detector. ">vox_cd</a></code>. Later you attach your camera and your rendering context (that means, the whole scene) to this structure. Once in a rendering loop you do <code><a class="el" href="cd_8h.html#a3c7286fead69d22818c9b7b9cda95427" title="Perform collision detection. ">vox_cd_collide()</a></code>. This automatically checks camera position and if it collides with any part of a tree, its previous valid position is restored. An example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structvox__rnd__ctx.html">vox_rnd_ctx</a> *ctx =</div><div class="line">     <a class="code" href="renderer_8h.html#aaf81b81464cedd74adb3ef36a45bb977">vox_make_context_and_window</a> (800, 600);</div><div class="line"><a class="code" href="renderer_8h.html#a70b28356c826fe55a989c88130365aba">vox_context_set_scene</a> (ctx, tree);</div><div class="line"><a class="code" href="renderer_8h.html#a67d94618f634ad5c180883893c70dcea">vox_context_set_camera</a> (ctx, camera);</div><div class="line"><span class="keyword">struct </span><a class="code" href="structvox__cd.html">vox_cd</a> *cd = <a class="code" href="cd_8h.html#a9a5c42383ece1e3542105c3b29dd6ded">vox_make_cd</a> ();</div><div class="line"><a class="code" href="cd_8h.html#a3f02202e9a88612d8cfd12b16d0f8b60">vox_cd_attach_camera</a> (cd, camera, 4); <span class="comment">// 4 is the camera&#39;s body radius</span></div><div class="line"><a class="code" href="cd_8h.html#ad5fec4a52f12401eeb9af24ca80da7a8">vox_cd_attach_context</a> (cd, ctx);</div><div class="line"><span class="keywordflow">while</span> (1) {</div><div class="line">    <a class="code" href="renderer_8h.html#ade0726b6cf99eab1508e6e7e6bc72480">vox_render</a> (ctx);</div><div class="line">    <a class="code" href="cd_8h.html#a3c7286fead69d22818c9b7b9cda95427">vox_cd_collide</a> (cd);</div><div class="line">    ....</div><div class="line">}</div><div class="line">done:</div><div class="line">free (cd);</div><div class="line"><span class="comment">// And so on</span></div></div><!-- fragment --><h3>FPS control</h3>
<p><b>voxrnd</b> has its own FPS counter and controller. It is created using <code><a class="el" href="fps-control_8h.html#a694d0f0bef047cfcfd7c7548097b5024" title="Make FPS controller. ">vox_make_fps_controller()</a></code> function and destroyed with <code><a class="el" href="fps-control_8h.html#a5abaaad53f15f6facd80d6a9c31140e7" title="Destroy FPS controller created earlier. ">vox_destroy_fps_controller()</a></code>. <code><a class="el" href="fps-control_8h.html#a694d0f0bef047cfcfd7c7548097b5024" title="Make FPS controller. ">vox_make_fps_controller()</a></code> takes a desired number of frames per second (or just <code>0</code> if you do not want to restrict value of FPS and want just to count it). It returns a block of type <code>vox_fps_controller_t</code> which you must call once in a rendering loop to do its work. Look at this for example:</p>
<div class="fragment"><div class="line"><span class="comment">// Restrict the value of frames per second by 30</span></div><div class="line"><a class="code" href="fps-control_8h.html#a9afc8884bac15210515e8e5ca887800f">vox_fps_controller_t</a> fps_counter = <a class="code" href="fps-control_8h.html#a694d0f0bef047cfcfd7c7548097b5024">vox_make_fps_controller</a> (30);</div><div class="line"><span class="keywordflow">while</span> (keep_rendering) {</div><div class="line">    .......</div><div class="line">    <a class="code" href="renderer_8h.html#ade0726b6cf99eab1508e6e7e6bc72480">vox_render</a> (ctx);</div><div class="line">    <a class="code" href="renderer_8h.html#a91509c84451323b39ba51d6e334115ac">vox_redraw</a> (ctx);</div><div class="line">    .......</div><div class="line">    <span class="comment">// fps_info contains some useful info about actual FPS rate and frame</span></div><div class="line">    <span class="comment">// rendering time.</span></div><div class="line">    <span class="keyword">struct </span><a class="code" href="structvox__fps__info.html">vox_fps_info</a> fps_info = fps_counter();</div><div class="line">}</div><div class="line">done:</div><div class="line"><a class="code" href="fps-control_8h.html#a5abaaad53f15f6facd80d6a9c31140e7">vox_destroy_fps_controller</a> (fps_counter);</div></div><!-- fragment --><p> See API documentation for more info.</p>
<h2>Voxengine </h2>
<p><b>Voxengine</b> is somewhat a combine library, integrating all other libraries of voxvision, SDL2 and lua scripting. A lifecycle of an application which uses <b>voxengine</b> can be similar to the following:</p><ol type="1">
<li>You create an engine by calling <code><a class="el" href="engine_8h.html#a7a18256f0e8c64e47fe469c6ee391375" title="Create voxengine. ">vox_create_engine()</a></code> passing your lua control script as a parameter.</li>
<li>In infinite loop you call <code><a class="el" href="engine_8h.html#aa57c2c7777aa085ace8d64d252e149a0" title="Engine tick function. ">vox_engine_tick()</a></code> to render a new frame and update the engine's state. Optionally you can do anything you want to do in this loop, e.g. use FPS counter.</li>
<li>You check if lua control script has requested to stop the engine by calling <code><a class="el" href="engine_8h.html#aba7de9a6a3e8af68467d9b5dd635fc91" title="Return true if quit was requested from the control script. ">vox_engine_quit_requested()</a></code> passing the status returned by <code><a class="el" href="engine_8h.html#aa57c2c7777aa085ace8d64d252e149a0" title="Engine tick function. ">vox_engine_tick()</a></code> as a parameter.</li>
<li>In case you deside to quit, jump out of the loop and call <code><a class="el" href="engine_8h.html#a2fc5334f93dfce5cd2600eec18a72806" title="Destroy an engine. ">vox_destroy_engine()</a></code>.</li>
<li>Do all SDL event handling in lua script using <b>luasdl2</b> written by Tangent128 (see below). If you wish to quit, return <code>false</code> from <code>tick()</code> function, otherwise return <code>true</code> (see below).</li>
</ol>
<p>Here is an example: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Creating an engine and a window with dimensions 800x600. The last two</span></div><div class="line"><span class="comment">     * arguments can be ignored now (they are explained in API documentation.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">struct </span><a class="code" href="structvox__engine.html">vox_engine</a> *engine = <a class="code" href="engine_8h.html#a7a18256f0e8c64e47fe469c6ee391375">vox_create_engine</a> (800, 600, 0, script, 0, NULL);</div><div class="line">    <span class="keywordflow">if</span> (engine == NULL) {</div><div class="line">        <span class="comment">// vox_create_engine reports an error.</span></div><div class="line">        <span class="comment">// Quit here</span></div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">while</span> (1) {</div><div class="line">        <a class="code" href="engine_8h.html#a10e4dba1fec7265413639699bbacef07">vox_engine_status</a> status = <a class="code" href="engine_8h.html#aa57c2c7777aa085ace8d64d252e149a0">vox_engine_tick</a> (engine);</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="engine_8h.html#aba7de9a6a3e8af68467d9b5dd635fc91">vox_engine_quit_requested</a> (status)) <span class="keywordflow">goto</span> done;</div><div class="line">    }</div><div class="line"></div><div class="line">done:</div><div class="line">    <a class="code" href="engine_8h.html#a2fc5334f93dfce5cd2600eec18a72806">vox_destroy_engine</a> (engine);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>There is an example program, <b>voxvision-engine</b>, in this project. It demonstates the use of <b>voxengine</b>. You can see its source code in <code>src/demo2</code> directory.</p>
<p>The power of <b>voxengine</b> comes with lua. A lua control script (the one you passed with <code>-s</code> argument, if you use <b>voxvision-engine</b>) is executed in protected environment and must at least contain <code>init</code> function. This environment includes (but is not limited to):</p><ul>
<li>Standard <code>print</code>, <code>pairs</code>, <code>ipairs</code>, <code>next</code>, <code>unpack</code>, <code>tostring</code>, <code>tonumber</code> functions.</li>
<li>Almost all from math module in <code>math</code> table</li>
<li><code>os.clock</code></li>
<li><code>table.insert</code>, <code>table.remove</code>, <code>table.maxn</code>, <code>table.sort</code> functions</li>
<li><code>voxtrees</code>, <code>voxrnd</code> and <code>voxutils</code> modules</li>
<li>Some functions and tables from <b>luasdl2</b>, such as <code>getKeyboardState</code>, <code>pollEvent</code>, <code>pumpEvent</code>, <code>waitEvent</code>, <code>key</code>, <code>event</code>, <code>scancode</code> etc. in <code>voxsdl</code> table.</li>
</ul>
<p>You can get the full list of available functions/tables/variables if you look at <code>src/voxengine/genenvironment.py</code> and <code>src/voxengine/engine.c</code> files.</p>
<p><code>init</code> function takes a <em>renderer context</em> as a single argument. The <code>init</code> function must set up your world, i.e. add at least a camera and a tree to it. Values returned by init() are ignored. Let's see an example:</p>
<div class="fragment"><div class="line">vt = voxtrees</div><div class="line">vr = voxrnd</div><div class="line">vs = voxsdl</div><div class="line"></div><div class="line">function init (ctx)</div><div class="line">   -- Set voxel size</div><div class="line">   vt.voxelsize {0.25, 0.25, 0.25}</div><div class="line">   -- Create a set for up to 50*50*50 dots</div><div class="line">   local a = vt.dotset(50*50*50)</div><div class="line">   for i = 0,50 do</div><div class="line">      for j = 0,50 do</div><div class="line">         for k = 0,50 do</div><div class="line">            -- Push a new dot to the set</div><div class="line">            a:push {i,j,k}</div><div class="line">         end</div><div class="line">      end</div><div class="line">   end</div><div class="line">   -- Convert the set to a voxel tree</div><div class="line">   local t = vt.settree (a)</div><div class="line">   -- How many dots are in the tree?</div><div class="line">   print (#t)</div><div class="line"></div><div class="line">   -- Create a new simple camera</div><div class="line">   local camera = vr.camera &quot;simple-camera&quot;</div><div class="line">   --[[</div><div class="line">        These methods are like methods in vox_camera_interface.</div><div class="line">        You can set property of an object using &quot;object.property =&quot; scheme.</div><div class="line">   ]]--</div><div class="line">   camera.position = {25,-100,25}</div><div class="line">   camera.fov = 0.45</div><div class="line">   camera:look_at {25,25,25}</div><div class="line"></div><div class="line">   -- Populate the context</div><div class="line">   ctx.tree = t</div><div class="line">   ctx.camera = camera</div><div class="line">end</div><div class="line"></div><div class="line">function tick (world, time)</div><div class="line">   -- This is how events are handeled. Just like in C program</div><div class="line">   local event, quit</div><div class="line">   for event in vs.pollEvent() do</div><div class="line">      if event.type == vs.event.KeyDown and event.keysym.sym == vs.key.Escape then</div><div class="line">         quit = true</div><div class="line">      elseif event.type == vs.event.Quit then</div><div class="line">         quit = true</div><div class="line">      end</div><div class="line">   end</div><div class="line">   -- Return nil when you wish to shut down the engine</div><div class="line">   if quit then return nil end</div><div class="line"></div><div class="line">   -- You can rotate camera or modify tree in tick() function</div><div class="line">   local camera = world.camera</div><div class="line">   time = time / 2000</div><div class="line">   local dot = {25+125*math.sin(time),25-125*math.cos(time),25}</div><div class="line">   camera.position = dot</div><div class="line">   camera:look_at {25,25,25}</div><div class="line"></div><div class="line">   return true</div><div class="line">end</div></div><!-- fragment --><p>Another function seen in this example is <code>tick</code>. It is called once in the main loop when <code><a class="el" href="engine_8h.html#aa57c2c7777aa085ace8d64d252e149a0" title="Engine tick function. ">vox_engine_tick()</a></code> is called and used to update the scene. It accepts 2 arguments: your world and time in milliseconds from the start of the program. It must always return <code>true</code> unless you want to quit. This function is optional. If you do not supply it, <b>voxengine</b> will do basic SDL event handling by itself. Here is another example which brings more interaction with user:</p>
<div class="fragment"><div class="line">vt = voxtrees</div><div class="line">vr = voxrnd</div><div class="line">vs = voxsdl</div><div class="line"></div><div class="line">function init (ctx)</div><div class="line">   -- You can also create an empty tree</div><div class="line">   local t = vt.tree()</div><div class="line">   -- And add a voxel to it</div><div class="line">   t:insert {0,0,0}</div><div class="line"></div><div class="line">   local camera = vr.camera &quot;simple-camera&quot;</div><div class="line">   camera.position = {0,-10,0}</div><div class="line"></div><div class="line">   -- Here is a collision detector. Its interface is like its C equivalent</div><div class="line">   local cd = vr.cd()</div><div class="line">   cd:attach_camera (camera, 4)</div><div class="line">   cd:attach_context (ctx)</div><div class="line"></div><div class="line">   ctx.tree = t</div><div class="line">   ctx.camera = camera</div><div class="line">   -- You need also to keep a reference to collision detector in the context.</div><div class="line">   ctx.cd = cd</div><div class="line">end</div><div class="line"></div><div class="line">function tick (world, time)</div><div class="line">   local event, quit</div><div class="line">   for event in vs.pollEvent() do</div><div class="line">      if event.type == vs.event.KeyDown and event.keysym.sym == vs.key.Escape then</div><div class="line">         quit = true</div><div class="line">      elseif event.type == vs.event.Quit then</div><div class="line">         quit = true</div><div class="line">      end</div><div class="line">   end</div><div class="line">   if quit then return nil end</div><div class="line"></div><div class="line">   -- Here you can get the keyboard state with &#39;getKeyboardState&#39; function</div><div class="line">   local keystate = vs.getKeyboardState()</div><div class="line">   local camera = world.camera</div><div class="line">   --[[</div><div class="line">        You can check if a key is pressed in the following way.</div><div class="line">        This example implements WASD-movement and camera rotation.</div><div class="line">   ]]--</div><div class="line">   if keystate[vs.scancode.S] then</div><div class="line">      camera:move_camera {0,-5,0}</div><div class="line">   elseif keystate[vs.scancode.W] then</div><div class="line">      camera:move_camera {0,5,0}</div><div class="line">   end</div><div class="line"></div><div class="line">   if keystate[vs.scancode.A] then</div><div class="line">      camera:move_camera {-5,0,0}</div><div class="line">   elseif keystate[vs.scancode.D] then</div><div class="line">      camera:move_camera {5,0,0}</div><div class="line">   end</div><div class="line"></div><div class="line">   if keystate[vs.scancode.Left] then</div><div class="line">      camera:rotate_camera {0,0,0.05}</div><div class="line">   elseif keystate[vs.scancode.Right] then</div><div class="line">      camera:rotate_camera {0,0,-0.05}</div><div class="line">   end</div><div class="line"></div><div class="line">   if keystate[vs.scancode.Up] then</div><div class="line">      camera:rotate_camera {-0.05,0,0}</div><div class="line">   elseif keystate[vs.scancode.Down] then</div><div class="line">      camera:rotate_camera {0.05,0,0}</div><div class="line">   end</div><div class="line"></div><div class="line">   -- Check for collisions</div><div class="line">   world.cd:collide ()</div><div class="line"></div><div class="line">   return true</div><div class="line">end</div></div><!-- fragment --><p>Since version 0.31 you can also control fps rate from lua code. To do this, create fps controller in <code>init()</code> function like so: </p><div class="fragment"><div class="line">function init (ctx)</div><div class="line">   ......</div><div class="line">   -- Set frames per second ratio to 60</div><div class="line">   ctx.fps = voxrnd.fps_controller (60)</div><div class="line">end</div></div><!-- fragment --><p> Then call <code>ctx.fps:delay()</code> once in the <code>tick()</code> function. If you use this method, do NOT specify <code>-f</code> key to <code>voxvision-engine</code> program.</p>
<p><b>Voxengine</b>'s lua interface can interact with SDL by means of <a href="https://github.com/Tangent128/luasdl2"><b>luasdl2</b></a>. It can also understand raw data files, using <code><a class="el" href="datareader_8h.html#a429b98cbbbc3b80cad356e1bf38d6fef" title="Build a tree from raw density file. ">vox_read_raw_data()</a></code> from <b>voxtrees</b>. Please look at lua scripts in <code>example</code> directory. All memory required for such objects as trees, dotsets etc. is handeled by lua automatically.</p>
<p>There is debug mode in <b>voxengine</b>. To run <b>voxengine</b> in debug mode pass <code>VOX_ENGINE_DEBUG</code> as the third argument to <code>vox_create_engine</code> (see API documentation). In this mode, no context is created and SDL is not initialized. The engine runs only <code>init()</code> function with simple table as an argument and exits. It's useful for debugging <b>voxtrees</b> library. Calling <code><a class="el" href="engine_8h.html#aa57c2c7777aa085ace8d64d252e149a0" title="Engine tick function. ">vox_engine_tick()</a></code> in debug mode produce no effect.</p>
<h2>Demo application </h2>
<p><b>NB:</b> This section of documentation is out of the date.</p>
<p>This application is meant as a demonstration of <b>voxvision</b> libraries and as a developer's playground. I'll provide information on it here too.</p>
<h3>Controls</h3>
<p>Here is default keys for basic controls:</p>
<table class="doxtable">
<tr>
<th>Action </th><th>Key  </th></tr>
<tr>
<td>Tilt left </td><td><code>Z</code> </td></tr>
<tr>
<td>Tilt right </td><td><code>X</code> </td></tr>
<tr>
<td>Walk left </td><td><code>A</code> </td></tr>
<tr>
<td>Walk right </td><td><code>D</code> </td></tr>
<tr>
<td>Walk forwards </td><td><code>W</code> </td></tr>
<tr>
<td>Walk backwards </td><td><code>S</code> </td></tr>
<tr>
<td>Fly up </td><td><code>1</code> </td></tr>
<tr>
<td>Fly down </td><td><code>2</code> </td></tr>
<tr>
<td>Insert cube </td><td><code>I</code> </td></tr>
<tr>
<td>Delete cube </td><td><code>O</code> </td></tr>
</table>
<h3>Scene configuration files</h3>
<p>Configuration files are just old Windows <code>ini</code> files inside. There are 3 types of values there: numbers, vectors and strings. Numbers are any numbers: integers or floats, does not matter. A vector is triplet or (maybe) pair of numbers in format <code>&lt;x,y,z&gt;</code> or <code>&lt;x,y&gt;</code>, i.e. enclosed in angle brackets and separated by commas. Strings are enclosed in double quotes (<code>"</code>). Here is a table for each possible key and its meaning in scene configuration file:</p>
<table class="doxtable">
<tr>
<th>Section:Key </th><th>Type </th><th>Defaults to </th><th>Comment  </th></tr>
<tr>
<td><code>Scene:DataSet</code> </td><td>string </td><td>N/A </td><td>Dataset's file name, mandatory </td></tr>
<tr>
<td><code>Scene:Voxsize</code> </td><td>vector </td><td><code>&lt;1,1,1&gt;</code> </td><td>Size of a voxel </td></tr>
<tr>
<td><code>Scene:Geometry</code> </td><td>vector </td><td>N/A </td><td>Dimensions of dataset, mandatory </td></tr>
<tr>
<td><code>Scene:Threshold</code> </td><td>number </td><td><code>30</code> </td><td>Samples with value bigger than that are loaded </td></tr>
<tr>
<td><code>Scene:SampleSize</code> </td><td>number </td><td><code>1</code> </td><td>Size of sample (in bytes) </td></tr>
<tr>
<td><code>Camera:Position</code> </td><td>vector </td><td><code>&lt;0,-100,0&gt;</code> </td><td>Start with that camera position </td></tr>
<tr>
<td><code>Camera:Fov</code> </td><td>number </td><td><code>1</code> </td><td>Camera's field of view </td></tr>
<tr>
<td><code>Camera:Rot</code> </td><td>vector </td><td><code>&lt;0,0,0&gt;</code> </td><td>Start with that camera rotation </td></tr>
</table>
<p>Dataset is just a 3d array of little-endian binary coded samples, beginning with the first sample, immediately followed by another and so on, all having one sample size.</p>
<h3>Global configuration file</h3>
<p>Here you can remap controls and set window properties. Look at the table:</p>
<table class="doxtable">
<tr>
<th>Section:Key </th><th>Type </th><th>Defaults to </th><th>Comment  </th></tr>
<tr>
<td><code>Window:Width</code> </td><td>number </td><td><code>800</code> </td><td>Window's width </td></tr>
<tr>
<td><code>Window:Height</code> </td><td>number </td><td><code>600</code> </td><td>Window's height </td></tr>
<tr>
<td><code>Controls:MouseXSpeed</code> </td><td>number </td><td><code>0.01</code> </td><td>Mouse horizontal speed (May be less than zero to invert axis) </td></tr>
<tr>
<td><code>Controls:MouseYSpeed</code> </td><td>number </td><td><code>0.01</code> </td><td>Mouse vertical speed (May be less than zero to invert axis) </td></tr>
</table>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 15 2020 08:39:10 for Voxvision by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
